## 对象设计陷阱：太多对象

类似于之前讨论的关于太多合约状态对象的问题，一些开发人员常见的陷阱是创建过多的对象。
例如，对于笔记本电脑的情况，从技术上讲，你可以为每个笔记本电脑组件（如屏幕、键盘、硬盘等）创建一个单独的对象：

```move
public struct Laptop has key {
    id: UID,
    screen: Screen,
    keyboard: Keyboard,
    hard_drive: HardDrive,
}

public struct Screen has key, store {
    id: UID,
}

public struct Keyboard has key, store {
    id: UID,
}

public struct HardDrive has key, store {
    id: UID,
}
```
正如你所见，每个组件都是一个独立的对象。这是不必要的，因为屏幕、键盘和硬盘对象总是被包装在笔记本电脑对象中。它们从未作为独立对象分离出来。只有当我们有意将键盘作为一个独立组件销售并可以集成到另一台笔记本电脑中时，这种设计才有意义。如果我们经营的是一家硬件商店，这可能是需要的，但我们这里只是一个笔记本电脑商店。

Move 模块创建过多对象的其他问题：

- 如果一个交易创建和更改了太多对象，就很难理解。对于在探索器界面上查看这些交易的用户来说，他们看到的只是一个非常长的更新或创建的所有对象的列表，以及它们所有关联的字段/数据。如果列表中有 10 多个对象，这可能会让人不知所措。
- 如果用户需要与这些对象中的多个对象交互，构建交易会变得复杂，因为界面需要找到并传递所有相关对象的地址。
- 除了使用类似于我们在管理状态对象的课程中介绍的动态字段外，如果开发人员确实想创建许多不同类型的对象，他们还可以使用之前介绍的数据结构，如 ObjectBag 和 ObjectTable。这些数据结构可以将许多对象收集到一个易于理解和传递的容器对象中。