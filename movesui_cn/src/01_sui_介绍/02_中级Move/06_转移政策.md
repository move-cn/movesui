## 转移政策 - 对象的公共和私有转移

我们已经看到归属对象的两种操作方式：

```move
struct OwnedObject has key {
    id: UID,
}

public fun create_owned_object(tx_context: &mut TxContext) {
  let owned_object = OwnedObject {
      id: object::new(ctx),
  };
  transfer::transfer(owned_object, tx_context::sender(ctx));
}
```
我们还了解了结构体的能力 —— key, store, copy, drop。通过结合 store 能力和 transfer 模块提供的功能，你可以获得一个特殊的隐藏功能——转移政策。

通过转移政策，开发人员可以决定他们定义的对象是否可以在其模块代码之外进行转移：

1. 具有 store 能力的对象可以通过 `transfer::public_transfer` 在其定义的同一模块之外进行转移。

```move
module 0x123::my_module {
    struct OwnedObject has key, store {
        id: UID,
    }
}

module 0x123::your_module {
    use 0x123::my_module::OwnedObject;
    
    public fun transfer(object: OwnedObject, receiver: address) {
        transfer::public_transfer(object, receiver);
    }
}
```

2. 没有 store 能力的对象**只能**在其定义的同一模块内通过 `transfer::transfer` 转移。在上面的示例中，如果我们从 OwnedObject 中移除 store 能力，your_module 中的 transfer 函数将停止工作。OwnedObject 现在只能在 my_module 内直接转移：

```move
module 0x123::my_module {
    struct OwnedObject has key {
        id: UID,
    }
    
    public fun transfer(object: OwnedObject, receiver: address) {
        transfer::transfer(object, receiver);
    }
}
```